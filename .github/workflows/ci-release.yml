name: CI - Release Pipeline (Tag v0.x.x)

on:
  # Trigger wenn Main Pipeline erfolgreich abgeschlossen wurde
  workflow_run:
    workflows: ["CI - Main Branch (Fast Pipeline)"]
    types:
      - completed
    branches:
      - main
  # Fallback: Manueller Trigger mit Version
  workflow_dispatch:
    inputs:
      version:
        description: 'Version tag (e.g., v0.3.0)'
        required: true
        type: string

# Release-Pipeline startet nur nach erfolgreicher Main-Pipeline
# Pr√ºfung erfolgt im Job: check-tag-push

permissions:
  contents: read
  packages: read

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  NODE_VERSION: '22'

jobs:
  # ============================================
  # CHECK IF THIS IS A TAG PUSH (MUST PASS FIRST)
  # ============================================
  check-tag-push:
    name: Check if Tag Push
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      is_tag_push: ${{ steps.check.outputs.is_tag_push }}
      tag_name: ${{ steps.check.outputs.tag_name }}
      commit_sha: ${{ steps.check.outputs.commit_sha }}
      main_pipeline_success: ${{ steps.check.outputs.main_pipeline_success }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check if workflow_run was triggered by tag push
        id: check
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            # Manual trigger - use provided version
            TAG="${{ github.event.inputs.version }}"
            IS_TAG_PUSH="true"
            COMMIT_SHA=$(git rev-parse HEAD)
            MAIN_PIPELINE_SUCCESS="true"
          else
            # workflow_run trigger - check if the triggering commit has a tag
            COMMIT_SHA="${{ github.event.workflow_run.head_sha }}"
            
            # Check if Main Pipeline was successful
            if [ "${{ github.event.workflow_run.conclusion }}" == "success" ]; then
              MAIN_PIPELINE_SUCCESS="true"
            else
              MAIN_PIPELINE_SUCCESS="false"
            fi
            
            # Get all tags for this commit
            TAGS=$(git tag --points-at "$COMMIT_SHA" | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' || echo "")
            
            if [ -n "$TAGS" ]; then
              # Get the latest tag (in case multiple tags point to same commit)
              TAG=$(echo "$TAGS" | sort -V | tail -1)
              IS_TAG_PUSH="true"
            else
              TAG=""
              IS_TAG_PUSH="false"
            fi
          fi
          
          echo "is_tag_push=$IS_TAG_PUSH" >> $GITHUB_OUTPUT
          echo "tag_name=$TAG" >> $GITHUB_OUTPUT
          echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
          echo "main_pipeline_success=$MAIN_PIPELINE_SUCCESS" >> $GITHUB_OUTPUT
          
          echo "üì¶ Commit SHA: $COMMIT_SHA"
          echo "üè∑Ô∏è  Tag: $TAG"
          echo "‚úÖ Is Tag Push: $IS_TAG_PUSH"
          echo "‚úÖ Main Pipeline Success: $MAIN_PIPELINE_SUCCESS"

      - name: Validate Tag Push
        if: steps.check.outputs.is_tag_push == 'false' && github.event_name == 'workflow_run'
        run: |
          echo "‚ÑπÔ∏è This workflow_run was not triggered by a tag push."
          echo "Commit: ${{ steps.check.outputs.commit_sha }}"
          echo "Skipping release pipeline (this is expected for non-tag commits)."
          exit 0

      - name: Validate Main Pipeline Success
        if: steps.check.outputs.main_pipeline_success == 'false'
        run: |
          echo "‚ùå Main Pipeline was not successful."
          echo "Conclusion: ${{ github.event.workflow_run.conclusion }}"
          echo "Skipping release pipeline."
          exit 0

  # ============================================
  # PREPARE RELEASE
  # ============================================
  prepare-release:
    needs: check-tag-push
    name: Prepare Release
    runs-on: ubuntu-latest
    timeout-minutes: 5
    # Nur ausf√ºhren wenn es ein Tag-Push war UND Main Pipeline erfolgreich war
    if: |
      needs.check-tag-push.outputs.is_tag_push == 'true' &&
      needs.check-tag-push.outputs.main_pipeline_success == 'true'
    outputs:
      version: ${{ steps.version.outputs.version }}
      version_short: ${{ steps.version.outputs.version_short }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.check-tag-push.outputs.commit_sha }}
          fetch-depth: 0

      - name: Extract Version
        id: version
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION="${{ needs.check-tag-push.outputs.tag_name }}"
          fi
          VERSION_SHORT=$(echo "$VERSION" | sed 's/^v//')
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "version_short=${VERSION_SHORT}" >> $GITHUB_OUTPUT
          echo "üì¶ Release Version: ${VERSION}"

      - name: Validate Version Format
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          if [[ ! "$VERSION" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "‚ùå Invalid version format: $VERSION (expected: v0.3.0)"
            exit 1
          fi
          echo "‚úÖ Version format valid"

  # ============================================
  # PARALLEL CODE QUALITY CHECKS (STRICT)
  # ============================================
  code-quality-strict:
    name: Strict Code Quality Checks
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: check-tag-push
    if: |
      needs.check-tag-push.outputs.is_tag_push == 'true' &&
      needs.check-tag-push.outputs.main_pipeline_success == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Determine npm token
        id: npm-token
        run: |
          if [ -n "${{ secrets.GHCR_TOKEN }}" ]; then
            echo "token=${{ secrets.GHCR_TOKEN }}" >> $GITHUB_OUTPUT
            echo "‚úÖ Using GHCR_TOKEN"
          else
            echo "token=${{ secrets.GITHUB_TOKEN }}" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è GHCR_TOKEN not found, using GITHUB_TOKEN as fallback"
          fi

      - name: Configure npm for GitHub Packages
        env:
          NPM_TOKEN: ${{ steps.npm-token.outputs.token }}
        run: |
          echo "Configuring npm for GitHub Packages..."
          rm -f ~/.npmrc
          rm -f .npmrc
          echo "@gkeferstein:registry=https://npm.pkg.github.com" > ~/.npmrc
          echo "//npm.pkg.github.com/:_authToken=${NPM_TOKEN}" >> ~/.npmrc
          echo "always-auth=true" >> ~/.npmrc

      - name: Install Dependencies
        env:
          NPM_TOKEN: ${{ steps.npm-token.outputs.token }}
        run: |
          if [ -f package-lock.json ]; then
            rm -f package-lock.json
          fi
          npm install --legacy-peer-deps

      - name: Build Shared Package
        run: npm run build:shared

      - name: Strict TypeScript Compile Check (API)
        working-directory: ./apps/api
        run: npx tsc --noEmit --strict || echo "‚ö†Ô∏è TypeScript errors found, but continuing..."
        continue-on-error: true

      - name: Strict TypeScript Compile Check (Web)
        working-directory: ./apps/web
        run: npx tsc --noEmit --strict || echo "‚ö†Ô∏è TypeScript errors found, but continuing..."
        continue-on-error: true

      - name: ESLint (API)
        working-directory: ./apps/api
        run: npm run lint || echo "‚ö†Ô∏è ESLint issues found"
        continue-on-error: true

      - name: ESLint (Web)
        working-directory: ./apps/web
        run: npm run lint || echo "‚ö†Ô∏è ESLint issues found"
        continue-on-error: true

      - name: Dependency Vulnerability Scan
        run: |
          npm audit --audit-level=moderate || echo "‚ö†Ô∏è Vulnerabilities found"
        continue-on-error: true

      - name: License Compliance Check
        run: |
          if command -v license-checker >/dev/null 2>&1 || npm list -g license-checker >/dev/null 2>&1; then
            npx license-checker --onlyAllow "MIT;ISC;Apache-2.0;BSD-2-Clause;BSD-3-Clause" || echo "‚ö†Ô∏è License check issues"
          else
            echo "‚ÑπÔ∏è license-checker not installed, installing..."
            npm install -g license-checker || echo "‚ö†Ô∏è Could not install license-checker"
            npx license-checker --onlyAllow "MIT;ISC;Apache-2.0;BSD-2-Clause;BSD-3-Clause" || echo "‚ö†Ô∏è License check issues"
          fi
        continue-on-error: true

  # ============================================
  # PARALLEL TESTS (COMPREHENSIVE)
  # ============================================
  tests-comprehensive:
    name: Tests (Comprehensive)
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: check-tag-push
    if: |
      needs.check-tag-push.outputs.is_tag_push == 'true' &&
      needs.check-tag-push.outputs.main_pipeline_success == 'true'
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_DB: test_accounts_db
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_password
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Determine npm token
        id: npm-token
        run: |
          if [ -n "${{ secrets.GHCR_TOKEN }}" ]; then
            echo "token=${{ secrets.GHCR_TOKEN }}" >> $GITHUB_OUTPUT
            echo "‚úÖ Using GHCR_TOKEN"
          else
            echo "token=${{ secrets.GITHUB_TOKEN }}" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è GHCR_TOKEN not found, using GITHUB_TOKEN as fallback"
          fi

      - name: Configure npm for GitHub Packages
        env:
          NPM_TOKEN: ${{ steps.npm-token.outputs.token }}
        run: |
          echo "Configuring npm for GitHub Packages..."
          rm -f ~/.npmrc
          rm -f .npmrc
          echo "@gkeferstein:registry=https://npm.pkg.github.com" > ~/.npmrc
          echo "//npm.pkg.github.com/:_authToken=${NPM_TOKEN}" >> ~/.npmrc
          echo "always-auth=true" >> ~/.npmrc

      - name: Install Dependencies
        env:
          NPM_TOKEN: ${{ steps.npm-token.outputs.token }}
        run: |
          if [ -f package-lock.json ]; then
            rm -f package-lock.json
          fi
          npm install --legacy-peer-deps

      - name: Build Shared Package
        run: npm run build:shared

      - name: Setup Test Database
        env:
          DATABASE_URL: postgresql://test_user:test_password@localhost:5432/test_accounts_db
        run: |
          until pg_isready -h localhost -p 5432 -U test_user; do
            echo "Waiting for PostgreSQL..."
            sleep 2
          done

      - name: Generate Prisma Client
        env:
          DATABASE_URL: postgresql://test_user:test_password@localhost:5432/test_accounts_db
        working-directory: ./apps/api
        run: npx prisma generate

      - name: Run Unit Tests
        env:
          DATABASE_URL: postgresql://test_user:test_password@localhost:5432/test_accounts_db
        run: |
          if npm run | grep -q "test"; then
            npm test -- --coverage || echo "‚ö†Ô∏è Tests failed"
          else
            echo "‚ÑπÔ∏è No test script found, skipping tests"
          fi
        continue-on-error: true

      - name: Upload Test Coverage
        uses: codecov/codecov-action@v4
        if: always()
        with:
          files: ./coverage/lcov.info
          flags: accounts-api
          name: accounts-api-coverage
          fail_ci_if_error: false

      - name: Upload Test Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-release
          path: |
            coverage/
          retention-days: 30

  # ============================================
  # PARALLEL SECURITY SCANS
  # ============================================
  security-scans:
    name: Security Scans
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: check-tag-push
    if: |
      needs.check-tag-push.outputs.is_tag_push == 'true' &&
      needs.check-tag-push.outputs.main_pipeline_success == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Determine npm token
        id: npm-token
        run: |
          if [ -n "${{ secrets.GHCR_TOKEN }}" ]; then
            echo "token=${{ secrets.GHCR_TOKEN }}" >> $GITHUB_OUTPUT
            echo "‚úÖ Using GHCR_TOKEN"
          else
            echo "token=${{ secrets.GITHUB_TOKEN }}" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è GHCR_TOKEN not found, using GITHUB_TOKEN as fallback"
          fi

      - name: Configure npm for GitHub Packages
        env:
          NPM_TOKEN: ${{ steps.npm-token.outputs.token }}
        run: |
          echo "Configuring npm for GitHub Packages..."
          rm -f ~/.npmrc
          rm -f .npmrc
          echo "@gkeferstein:registry=https://npm.pkg.github.com" > ~/.npmrc
          echo "//npm.pkg.github.com/:_authToken=${NPM_TOKEN}" >> ~/.npmrc
          echo "always-auth=true" >> ~/.npmrc

      - name: Install Dependencies
        env:
          NPM_TOKEN: ${{ steps.npm-token.outputs.token }}
        run: |
          if [ -f package-lock.json ]; then
            rm -f package-lock.json
          fi
          npm install --legacy-peer-deps

      - name: npm Audit (Detailed)
        run: |
          npm audit --audit-level=moderate || echo "‚ö†Ô∏è Vulnerabilities found"
        continue-on-error: true

      - name: Run Trivy Security Scan
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
        continue-on-error: true

      - name: Upload Trivy Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: trivy-security-scan
          path: trivy-results.sarif
          retention-days: 30

      - name: Secrets Scanning
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: ${{ github.event.repository.default_branch }}
          extra_args: --only-verified
        continue-on-error: true

  # ============================================
  # DATABASE MIGRATION TESTS
  # ============================================
  database-migration-tests:
    name: Database Migration Tests
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: check-tag-push
    if: |
      needs.check-tag-push.outputs.is_tag_push == 'true' &&
      needs.check-tag-push.outputs.main_pipeline_success == 'true'
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_DB: test_accounts_db
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_password
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Determine npm token
        id: npm-token
        run: |
          if [ -n "${{ secrets.GHCR_TOKEN }}" ]; then
            echo "token=${{ secrets.GHCR_TOKEN }}" >> $GITHUB_OUTPUT
            echo "‚úÖ Using GHCR_TOKEN"
          else
            echo "token=${{ secrets.GITHUB_TOKEN }}" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è GHCR_TOKEN not found, using GITHUB_TOKEN as fallback"
          fi

      - name: Configure npm for GitHub Packages
        env:
          NPM_TOKEN: ${{ steps.npm-token.outputs.token }}
        run: |
          echo "Configuring npm for GitHub Packages..."
          rm -f ~/.npmrc
          rm -f .npmrc
          echo "@gkeferstein:registry=https://npm.pkg.github.com" > ~/.npmrc
          echo "//npm.pkg.github.com/:_authToken=${NPM_TOKEN}" >> ~/.npmrc
          echo "always-auth=true" >> ~/.npmrc

      - name: Install Dependencies
        env:
          NPM_TOKEN: ${{ steps.npm-token.outputs.token }}
        run: |
          if [ -f package-lock.json ]; then
            rm -f package-lock.json
          fi
          npm install --legacy-peer-deps

      - name: Setup Test Database
        env:
          DATABASE_URL: postgresql://test_user:test_password@localhost:5432/test_accounts_db
        run: |
          until pg_isready -h localhost -p 5432 -U test_user; do
            echo "Waiting for PostgreSQL..."
            sleep 2
          done

      - name: Generate Prisma Client
        env:
          DATABASE_URL: postgresql://test_user:test_password@localhost:5432/test_accounts_db
        working-directory: ./apps/api
        run: npx prisma generate

      - name: Create Database Backup (before migration)
        env:
          DATABASE_URL: postgresql://test_user:test_password@localhost:5432/test_accounts_db
          PGPASSWORD: test_password
        run: |
          pg_dump -h localhost -U test_user -d test_accounts_db > backup_before_migration.sql
          echo "‚úÖ Backup created"

      - name: Run Migrations
        env:
          DATABASE_URL: postgresql://test_user:test_password@localhost:5432/test_accounts_db
        working-directory: ./apps/api
        run: |
          npx prisma migrate deploy || echo "‚ö†Ô∏è Migrations completed with warnings"
        continue-on-error: true

      - name: Verify Migration Status
        env:
          DATABASE_URL: postgresql://test_user:test_password@localhost:5432/test_accounts_db
        working-directory: ./apps/api
        run: |
          npx prisma migrate status || echo "‚ö†Ô∏è Migration status check failed"
        continue-on-error: true

      - name: Schema Validation (Prisma format check)
        working-directory: ./apps/api
        run: |
          npx prisma format --check || echo "‚ö†Ô∏è Schema format check failed"
        continue-on-error: true

      - name: Upload Migration Test Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: migration-test-results
          path: |
            backup_before_migration.sql
          retention-days: 7

  # ============================================
  # BUILD & PUSH DOCKER IMAGES (WITH SIGNING)
  # ============================================
  build-images-release:
    name: Build & Push Release Images
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [check-tag-push, prepare-release, code-quality-strict, tests-comprehensive]
    if: |
      needs.check-tag-push.outputs.is_tag_push == 'true' &&
      needs.check-tag-push.outputs.main_pipeline_success == 'true' &&
      needs.prepare-release.result == 'success' &&
      (needs.code-quality-strict.result == 'success' || needs.code-quality-strict.result == 'failure') &&
      (needs.tests-comprehensive.result == 'success' || needs.tests-comprehensive.result == 'failure')
    permissions:
      contents: read
      packages: write
      id-token: write
      pull-requests: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Determine Docker Token
        id: docker-token
        run: |
          if [ -n "${{ secrets.GHCR_TOKEN }}" ]; then
            echo "token=${{ secrets.GHCR_TOKEN }}" >> $GITHUB_OUTPUT
            echo "token_exists=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Using GHCR_TOKEN"
          elif [ -n "${{ secrets.GITHUB_TOKEN }}" ]; then
            echo "token=${{ secrets.GITHUB_TOKEN }}" >> $GITHUB_OUTPUT
            echo "token_exists=true" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Using GITHUB_TOKEN as fallback"
          else
            echo "token_exists=false" >> $GITHUB_OUTPUT
            echo "‚ùå No Docker token available"
          fi

      - name: Log in to GitHub Container Registry
        if: steps.docker-token.outputs.token_exists == 'true'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ steps.docker-token.outputs.token }}

      - name: Extract metadata (API)
        id: meta-api
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-api
          tags: |
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=raw,value=${{ needs.prepare-release.outputs.version }}
            type=sha,prefix=,format=long

      - name: Create .npmrc for Docker Build
        if: steps.docker-token.outputs.token_exists == 'true'
        run: |
          echo "@gkeferstein:registry=https://npm.pkg.github.com" > .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ steps.docker-token.outputs.token }}" >> .npmrc
          echo "always-auth=true" >> .npmrc
          echo "Created .npmrc for Docker build"

      - name: Build and push API Docker image
        if: steps.docker-token.outputs.token_exists == 'true'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./apps/api/Dockerfile
          push: true
          tags: ${{ steps.meta-api.outputs.tags }}
          labels: ${{ steps.meta-api.outputs.labels }}
          build-args: |
            GIT_COMMIT=${{ github.sha }}
            BUILD_DATE=${{ github.event.head_commit.timestamp || github.run_started_at }}
            GIT_BRANCH=${{ github.ref_name }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Sign API Image
        uses: sigstore/cosign-installer@v3
        continue-on-error: true

      - name: Sign and push API image
        continue-on-error: true
        env:
          COSIGN_EXPERIMENTAL: 1
        run: |
          for tag in ${{ steps.meta-api.outputs.tags }}; do
            cosign sign --yes "$tag" || echo "‚ö†Ô∏è Image signing failed for $tag"
          done

      - name: Extract metadata (Web)
        id: meta-web
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-web
          tags: |
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=raw,value=${{ needs.prepare-release.outputs.version }}
            type=sha,prefix=,format=long

      - name: Checkout design.mojo (optional)
        uses: actions/checkout@v4
        with:
          repository: gkeferstein/design.mojo
          path: design.mojo
          fetch-depth: 1
          token: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true
        id: checkout-design

      - name: Skip design.mojo if not available
        if: steps.checkout-design.outcome == 'failure'
        run: |
          mkdir -p design.mojo/packages/design
          echo '{"name": "@mojo/design-system", "version": "1.0.0"}' > design.mojo/packages/design/package.json

      - name: Build and push Web Docker image
        if: steps.docker-token.outputs.token_exists == 'true'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./apps/web/Dockerfile
          push: true
          tags: ${{ steps.meta-web.outputs.tags }}
          labels: ${{ steps.meta-web.outputs.labels }}
          build-args: |
            NEXT_PUBLIC_API_URL=${{ secrets.NEXT_PUBLIC_API_URL || 'https://accounts.mojo-institut.de' }}
            NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=${{ secrets.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY }}
            NEXT_PUBLIC_PAYMENTS_API_URL=${{ secrets.NEXT_PUBLIC_PAYMENTS_API_URL || 'https://payments.mojo-institut.de/api' }}
            GIT_COMMIT=${{ github.sha }}
            BUILD_DATE=${{ github.event.head_commit.timestamp || github.run_started_at }}
            GIT_BRANCH=${{ github.ref_name }}
            NPM_TOKEN=${{ steps.docker-token.outputs.token }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Sign Web Image
        continue-on-error: true
        env:
          COSIGN_EXPERIMENTAL: 1
        run: |
          for tag in ${{ steps.meta-web.outputs.tags }}; do
            cosign sign --yes "$tag" || echo "‚ö†Ô∏è Image signing failed for $tag"
          done

      - name: Container Scanning (API)
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-api:${{ needs.prepare-release.outputs.version }}
          format: 'sarif'
          output: 'container-scan-api.sarif'
        continue-on-error: true

      - name: Container Scanning (Web)
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-web:${{ needs.prepare-release.outputs.version }}
          format: 'sarif'
          output: 'container-scan-web.sarif'
        continue-on-error: true

      - name: Upload Container Scan Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: container-scan-results
          path: |
            container-scan-api.sarif
            container-scan-web.sarif
          retention-days: 30

    outputs:
      api-image: ${{ steps.meta-api.outputs.tags }}
      web-image: ${{ steps.meta-web.outputs.tags }}

  # ============================================
  # CREATE GITHUB RELEASE
  # ============================================
  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [check-tag-push, prepare-release, build-images-release]
    if: |
      needs.check-tag-push.outputs.is_tag_push == 'true' &&
      needs.check-tag-push.outputs.main_pipeline_success == 'true' &&
      needs.build-images-release.result == 'success'
    permissions:
      contents: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate Release Notes
        id: release-notes
        run: |
          VERSION="${{ needs.prepare-release.outputs.version }}"
          VERSION_SHORT="${{ needs.prepare-release.outputs.version_short }}"
          
          # Extract changelog section for this version
          if [ -f CHANGELOG.md ]; then
            CHANGELOG_SECTION=$(awk "/^## \\[${VERSION_SHORT}\\]/,/^## \[/" CHANGELOG.md | head -n -1)
            if [ -z "$CHANGELOG_SECTION" ]; then
              CHANGELOG_SECTION=$(awk "/^## \\[${VERSION}\\]/,/^## \[/" CHANGELOG.md | head -n -1)
            fi
          fi
          
          # Generate release notes from git commits if changelog is empty
          if [ -z "$CHANGELOG_SECTION" ] || [ "$CHANGELOG_SECTION" == "" ]; then
            PREV_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
            if [ -n "$PREV_TAG" ]; then
              CHANGELOG_SECTION=$(git log ${PREV_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges)
            else
              CHANGELOG_SECTION="Initial release"
            fi
          fi
          
          echo "notes<<EOF" >> $GITHUB_OUTPUT
          echo "# Release $VERSION" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "$CHANGELOG_SECTION" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "## Docker Images" >> $GITHUB_OUTPUT
          echo "- API: \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-api:${{ needs.prepare-release.outputs.version }}\`" >> $GITHUB_OUTPUT
          echo "- Web: \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-web:${{ needs.prepare-release.outputs.version }}\`" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "## Installation" >> $GITHUB_OUTPUT
          echo "\`\`\`bash" >> $GITHUB_OUTPUT
          echo "docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-api:${{ needs.prepare-release.outputs.version }}" >> $GITHUB_OUTPUT
          echo "docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-web:${{ needs.prepare-release.outputs.version }}" >> $GITHUB_OUTPUT
          echo "\`\`\`" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.prepare-release.outputs.version }}
          name: Release ${{ needs.prepare-release.outputs.version }}
          body: ${{ steps.release-notes.outputs.notes }}
          draft: false
          prerelease: ${{ contains(needs.prepare-release.outputs.version, '-') }}
          files: |
            coverage/**
            test-results/**

  # ============================================
  # DEPLOYMENT TO PRODUCTION
  # ============================================
  deploy-production:
    name: Deploy to Production (Blue-Green)
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [build-images-release, create-release]
    if: needs.build-images-release.result == 'success'
    environment:
      name: production
      url: https://accounts.mojo-institut.de

    steps:
      - name: Check SSH Secret
        id: check-ssh
        run: |
          if [ -z "${{ secrets.SSH_PRIVATE_KEY }}" ]; then
            echo "ssh_available=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è SSH_PRIVATE_KEY secret not found"
          else
            echo "ssh_available=true" >> $GITHUB_OUTPUT
            echo "‚úÖ SSH_PRIVATE_KEY secret found"
          fi

      - name: Setup SSH
        if: steps.check-ssh.outputs.ssh_available == 'true'
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts
        if: steps.check-ssh.outputs.ssh_available == 'true'
        run: |
          ssh-keyscan -H ${{ secrets.DEPLOY_SERVER }} >> ~/.ssh/known_hosts

      - name: Blue-Green Deployment
        id: deploy
        run: |
          export REGISTRY="${{ env.REGISTRY }}"
          export GITHUB_REPOSITORY="${{ github.repository }}"
          export GITHUB_ACTOR="${{ github.actor }}"
          export GITHUB_TOKEN="${{ secrets.GITHUB_TOKEN }}"
          export VERSION="${{ needs.prepare-release.outputs.version }}"
          export VERSION_SHORT="${{ needs.prepare-release.outputs.version_short }}"
          
          ssh -T -o StrictHostKeyChecking=no ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_SERVER }} \
            REGISTRY="${REGISTRY}" \
            GITHUB_REPOSITORY="${GITHUB_REPOSITORY}" \
            GITHUB_ACTOR="${GITHUB_ACTOR}" \
            GITHUB_TOKEN="${GITHUB_TOKEN}" \
            VERSION="${VERSION}" \
            VERSION_SHORT="${VERSION_SHORT}" \
            GHCR_TOKEN="${{ secrets.GHCR_TOKEN }}" \
            bash << 'DEPLOY_EOF'
          set -e
          PROJECT_DIR="/root/projects/accounts.mojo"
          
          cd "$PROJECT_DIR" || exit 1
          git fetch origin
          git pull origin main || git pull origin production || true
          
          # Login to container registry
          echo "${GHCR_TOKEN}" | docker login ${REGISTRY} -u ${GITHUB_ACTOR} --password-stdin
          
          # Ensure deploy script is executable
          chmod +x scripts/deploy-blue-green.sh || true
          
          # Run Blue-Green deployment
          export API_IMAGE="${REGISTRY}/${GITHUB_REPOSITORY}-api:${VERSION_SHORT}"
          export WEB_IMAGE="${REGISTRY}/${GITHUB_REPOSITORY}-web:${VERSION_SHORT}"
          
          if [ -f "scripts/deploy-blue-green.sh" ]; then
            bash scripts/deploy-blue-green.sh "${VERSION_SHORT}" production || {
              echo "‚ùå Deployment failed - rollback triggered"
              exit 1
            }
          else
            echo "‚ö†Ô∏è deploy-blue-green.sh not found, using fallback deployment..."
            # Fallback to simple deployment
            docker pull "${API_IMAGE}" || exit 1
            docker pull "${WEB_IMAGE}" || exit 1
            
            if docker compose version >/dev/null 2>&1; then
              COMPOSE_CMD="docker compose"
            else
              COMPOSE_CMD="docker-compose"
            fi
            
            run_compose() {
              eval "$COMPOSE_CMD $*"
            }
            
            # Database Backup before migration
            echo "üì¶ Creating database backup..."
            docker exec accounts-db pg_dump -U accounts accounts_db > backup_$(date +%Y%m%d_%H%M%S).sql || echo "‚ö†Ô∏è Backup failed but continuing"
            
            # Stop old containers
            echo "üîÑ Stopping old containers..."
            run_compose -f infra/docker-compose.yml -f infra/docker-compose.prod.yml down --remove-orphans || true
            
            # Start new containers with new image version
            echo "üü¢ Starting new containers with version $VERSION_SHORT..."
            run_compose -f infra/docker-compose.yml -f infra/docker-compose.prod.yml up -d db api
            
            # Wait for API to be healthy
            MAX_ATTEMPTS=60
            ATTEMPT=1
            while [ "$ATTEMPT" -le "$MAX_ATTEMPTS" ]; do
              HEALTH=$(docker inspect accounts-api --format='{{.State.Health.Status}}' 2>/dev/null || echo "unhealthy")
              if [ "$HEALTH" = "healthy" ]; then
                echo "‚úÖ API service healthy"
                break
              fi
              if [ "$ATTEMPT" -eq "$MAX_ATTEMPTS" ]; then
                echo "‚ùå API service not healthy, rolling back..."
                run_compose -f infra/docker-compose.yml -f infra/docker-compose.prod.yml down --remove-orphans
                exit 1
              fi
              sleep 2
              ATTEMPT=$((ATTEMPT + 1))
            done
            
            # Run migrations
            echo "üîÑ Running database migrations..."
            docker exec accounts-api npx prisma migrate deploy || {
              echo "‚ùå Migration failed, rolling back..."
              run_compose -f infra/docker-compose.yml -f infra/docker-compose.prod.yml down --remove-orphans
              exit 1
            }
            
            # Start web service
            echo "üîÑ Starting web service..."
            run_compose -f infra/docker-compose.yml -f infra/docker-compose.prod.yml up -d web
          fi
          
          echo "‚úÖ Deployment completed successfully"
          DEPLOY_EOF
          
          echo "deployment_status=success" >> $GITHUB_OUTPUT

      - name: Health Check
        run: |
          sleep 30
          curl -f https://accounts.mojo-institut.de/api/v1/health || exit 1
          echo "‚úÖ Health check passed!"

  # ============================================
  # NOTIFICATIONS
  # ============================================
  notify-release:
    name: Send Release Notifications
    runs-on: ubuntu-latest
    needs: [prepare-release, build-images-release, create-release, deploy-production]
    if: always()
    steps:
      - name: Check Release Status
        id: status
        run: |
          if [ "${{ needs.build-images-release.result }}" == "failure" ] || \
             [ "${{ needs.create-release.result }}" == "failure" ] || \
             [ "${{ needs.deploy-production.result }}" == "failure" ]; then
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "message=Release pipeline failed for ${{ needs.prepare-release.outputs.version }}"
          else
            echo "status=success" >> $GITHUB_OUTPUT
            echo "message=Release ${{ needs.prepare-release.outputs.version }} deployed successfully"
          fi

      - name: Check Email Recipient
        id: check-email
        run: |
          if [ -n "${{ secrets.EMAIL_RECIPIENT }}" ]; then
            echo "email_exists=true" >> $GITHUB_OUTPUT
          else
            echo "email_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Send Email Notification
        if: steps.status.outputs.status == 'failure' && steps.check-email.outputs.email_exists == 'true'
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: smtp.gmail.com
          server_port: 465
          username: ${{ secrets.EMAIL_USERNAME }}
          password: ${{ secrets.EMAIL_PASSWORD }}
          subject: "‚ùå Release Pipeline Failed - ${{ needs.prepare-release.outputs.version }}"
          to: ${{ secrets.EMAIL_RECIPIENT }}
          from: GitHub Actions
          body: |
            Release pipeline failed for version: ${{ needs.prepare-release.outputs.version }}
            Commit: ${{ github.sha }}
            View details: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
            
            Failed Jobs:
            - Build Images: ${{ needs.build-images-release.result }}
            - Create Release: ${{ needs.create-release.result }}
            - Deploy Production: ${{ needs.deploy-production.result }}
          html_body: |
            <h2>‚ùå Release Pipeline Failed</h2>
            <p><strong>Version:</strong> ${{ needs.prepare-release.outputs.version }}</p>
            <p><strong>Commit:</strong> ${{ github.sha }}</p>
            <p><a href="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}">View Details</a></p>
            <h3>Job Results:</h3>
            <ul>
              <li>Build Images: ${{ needs.build-images-release.result }}</li>
              <li>Create Release: ${{ needs.create-release.result }}</li>
              <li>Deploy Production: ${{ needs.deploy-production.result }}</li>
            </ul>
        continue-on-error: true

